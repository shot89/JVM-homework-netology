# Задача "Понимание JVM"

## Описание
Просмотрите код ниже и опишите (текстово или с картинками) каждую строку с точки зрения происходящего в JVM  

Не забудьте упомянуть про: 
- ClassLoader'ы, 
- области памяти (стэк (и его фреймы), хип, метаспейс)  
- сборщик мусора

## Код для исследования
```java
public class JvmComprehension {
    public static void main(String[] args) {
        int i = 1;                      // 1
        Object o = new Object();        // 2
        Integer ii = 2;                 // 3
        printAll(o, i, ii);             // 4
        System.out.println("finished"); // 7
    }
    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5
        System.out.println(o.toString() + i + ii);  // 6
    }
}
```

## Решение

Сначала стартуют ClassLoader'ы для загрузки классов, своего ClassLoader'а у нас нет, поэтому имеем 3 стандартных:
- Bootstap и Platrorm Classloader загружают системные классы и классы, которые входят в сборку нашей версии JDK
- Application ClassLoader загружает наш класс JvmComprehension
  
Все классы загружаются в область памяти, называемую MetaSpace. Соответственно в нее загружается наш самописный класс JvmComprehension и системные классы необходимые для работы программы.

Когда стартует метод main в стеке создается фрейм для всех переменных примитивных типов и ссылок на объекты в heap

Разбор построчно:
1. int i = 1; - это примитив, поэтому он сразу записывается в Stack Memory во frame метода main
2. сначала создается новый объект Object в куче, после чего в Stack Memory во frame метода main записывается ссылка на только что созданный объект в переменную о
3. сначала создается новый объект Integer со значение 2 в куче, после чего в Stack Memory во frame метода main записывается ссылка на только что созданный объект в переменную ii 
4. frame метода main в Stack memory становеится недоступен, создается новый frame для метода printAll. В этот frame записываюся переменные, передаваемые методу, а именно int i полностью записывается в frame со значением, т.к. это примитив, переменным o и ii записываюся ссылки  на ранее созданные объекты в куче (2, 3)
5. сначала создается новый объект Integer со значение 700 в куче, после чего в Stack Memory во frame метода printAll записывается ссылка на только что созданный объект в переменную uselessVar
6. frame метода printAll в Stack memory становеится недоступен, создается новый frame для метода System.out.println. В HEAP записывается новый объкет типа String. Ссылка на этот объект записывается в Stack memory во frame System.out.println
7. Указатель в Stack memory возвращается к frame'у main, создается новый frame для метода System.out.println (из метода main). В HEAP записывается новый объкет типа String. Ссылка на этот объект записывается в Stack memory во frame System.out.println (из метода main)

GC может сработать, а может и нет. Мы на его работу никак не влиям. Работает по своим алгоритмам.
